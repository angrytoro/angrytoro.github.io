<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[freefish]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://blog.angrytoro.com/"/>
  <updated>2015-06-22T15:22:09.000Z</updated>
  <id>http://blog.angrytoro.com/</id>
  
  <author>
    <name><![CDATA[freefish]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[然而大部分期权并没有什么用]]></title>
    <link href="http://blog.angrytoro.com/2015/06/22/%E7%84%B6%E8%80%8C%E5%A4%A7%E9%83%A8%E5%88%86%E6%9C%9F%E6%9D%83%E5%B9%B6%E6%B2%A1%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8/"/>
    <id>http://blog.angrytoro.com/2015/06/22/然而大部分期权并没有什么用/</id>
    <published>2015-06-22T14:47:20.000Z</published>
    <updated>2015-06-22T15:22:09.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>首先声明下，这篇博文是引用自<strong>100offer</strong>的订阅号，献给非常单纯的程序员。由于最近实在是没有什么长进，一直在做业务，吃老本，陪妹子，所以没有自己的内容可以写（大哭）。不过可能接下去鄙人要在ghost上下点功夫，到时候就会有一些干货可以分享给大家啦。好了，废（zhen）话（luo）不（说）多说。</p>
</blockquote>
<p>最近有个用户拿到了Uber的offer，其中包含期权，他看不懂便向我咨询期权的细节和意义。我的观点是：大部分的期权并没有什么卵用。</p>
<h1 id="期权激励的初心">期权激励的初心</h1><p>其实期权是有正向作用的，让我们从目标谈起：<br><img src="/img/无股权激励下的公司与员工.jpg" alt="无股权激励下的公司与员工"><br>假设一家公司的目标是1，团队会形成分工来拆解目标，比如研发团队的目标可能是1.1，而一个普通程序员被分配到的目标可能是1.1.1。如果只有基本薪资，程序员认为出色完成1.1.1就完成了工作，因为这是全部目标。<br><a id="more"></a><br><img src="/img/股权或期权激励下的公司与员工.jpg" alt="股权或期权激励下的公司与员工"><br>但如果采用高薪资结合期权的激励方式，大家会分享到公司的成长。员工会向上寻找目标，完成整个部门的目标，甚至整个公司的目标也义不容辞。在这个过程中，员工不仅与公司一起快速成长，自身能力还得到了提升，良好的激励方式会形成一个双赢的局面。<br>就像 Fenng（冯大辉）虽然是技术负责人，但是看看他的社交媒体，满屏尽是「丁香园产品推广」——这或许也是Fenng大大给自己设定的目标吧！</p>
<h1 id="过去的互联网公司在处理「期权」这件事上，常出现这几种现象：">过去的互联网公司在处理「期权」这件事上，常出现这几种现象：</h1><p><strong>A、初创公司画饼忽悠</strong></p>
<p>A创业公司，招人时老板总谈降薪拿期权，爱招BAT背景的员工，口头禅是「员工要靠伴随公司成长来实现自我价值」。某员工降薪拿期权进入A公司，实际能力远高于offer岗位需求。工作了1年多后，他发现公司的成长完全不及预期，自己一直在做一些技术能力无法成长的事。失望之下，他试探了下外面的机会，发现世界变化很快，同类型的职位收到的薪资竟然是现公司的2~3倍。</p>
<p><strong>B、成长型公司打土豪易、分田地难</strong></p>
<p>B公司，国内风光一时的互联网上市公司，曾经期权是他们offer中重要的一环，某年12月IPO之夜，全公司员工们举杯、狂欢。然而现实很骨感，随着原先许诺好的期权变成了18：1换股，早期员工也失去了憧憬。</p>
<p><strong>C、上市公司的成熟分配机制</strong></p>
<p>阿里、百度、奇虎，为典型。期权被视为一种长期激励，而非利益捆绑。对优秀员工的激励方式是高薪资+部分期权。拿百度举例，T5工程师Package一般为30万/年，其中12-20%为期权；T9工程师Package一般为100~300万/年，40%左右为期权；由于已上市，兑现相对容易。<br><img src="/img/百度期权占比.jpg" alt="百度期权占比"></p>
<h1 id="那么，为何会出现AB式「反人性」的激励方式？">那么，为何会出现AB式「反人性」的激励方式？</h1><p>我想，A公司的老板是这么想的：<br><img src="/img/A公司老板的想法.jpg" alt="A公司老板的想法"></p>
<p>然并卵，员工的真实心理是这样的：<br><img src="/img/A公司员工想法.jpg" alt="A公司员工想法"></p>
<p>我太理解这种态度了，这种想法也是很合理的：期权到最后套现，是一个漫长不确定的路，如果我失去该得的薪资和奖金，时间成本和机会成本的损失是划不来的。</p>
<p>对于B公司，老板的心理活动也许是这样的：<br><img src="/img/B公司老板的想法.jpg" alt="B公司老板的想法"></p>
<p>B类公司过去也有成功者，分布在传统行业居多，他们的行业竞争并没有互联网领域激烈，让老板误认为「我就是那么牛逼」。对于「老二非死不可」的互联网行业，公司出现此类现象，更要警惕。</p>
<h1 id="So，普通员工/程序员如何辨别靠谱的互联网公司？">So，普通员工/程序员如何辨别靠谱的互联网公司？</h1><p>在期权这件事上，不同公司激励的方法、时间点均不相同，但靠谱的还是有几点共性：</p>
<p><strong>1、成功并长久的企业都会提供期权激励</strong><br>星巴克作为行业内绝对的利润垄断企业，期权激励应该也是星巴克成功的秘诀之一。<br><img src="/img/星巴克期权激励.jpg" alt="星巴克期权激励"></p>
<p><strong>2、对于普通员工，期权建立在合理薪资的基础上</strong><br>对于创业团队，期权+低工资的组合是很难招来靠谱的Team Leader的，用期权压低薪资的公司不太靠谱。</p>
<p><strong>3、期权激励后置且大方</strong><br>对比魅族和小米，我们可以发现与魅族不同的是，小米从第一天就很重视股权激励。留出足够的期权池，找到靠谱的团队，慷慨地配以股权或期权，是小米的特点。</p>
<p>最后，我想说，<br>如果能够获得必要的信息，同时自上而下地看问题，选择其实可以相对理性。但大部分情况下，你选择的不过是运气。若你斟酌了很久还在纠结，不如跟着第一感觉走。</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>首先声明下，这篇博文是引用自<strong>100offer</strong>的订阅号，献给非常单纯的程序员。由于最近实在是没有什么长进，一直在做业务，吃老本，陪妹子，所以没有自己的内容可以写（大哭）。不过可能接下去鄙人要在ghost上下点功夫，到时候就会有一些干货可以分享给大家啦。好了，废（zhen）话（luo）不（说）多说。</p>
</blockquote>
<p>最近有个用户拿到了Uber的offer，其中包含期权，他看不懂便向我咨询期权的细节和意义。我的观点是：大部分的期权并没有什么卵用。</p>
<h1 id="期权激励的初心">期权激励的初心</h1><p>其实期权是有正向作用的，让我们从目标谈起：<br><img src="/img/无股权激励下的公司与员工.jpg" alt="无股权激励下的公司与员工"><br>假设一家公司的目标是1，团队会形成分工来拆解目标，比如研发团队的目标可能是1.1，而一个普通程序员被分配到的目标可能是1.1.1。如果只有基本薪资，程序员认为出色完成1.1.1就完成了工作，因为这是全部目标。<br>]]>
    
    </summary>
    
      <category term="杂文" scheme="http://blog.angrytoro.com/categories/%E6%9D%82%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6 Generator]]></title>
    <link href="http://blog.angrytoro.com/2015/05/10/ES6-Generator/"/>
    <id>http://blog.angrytoro.com/2015/05/10/ES6-Generator/</id>
    <published>2015-05-10T14:42:49.000Z</published>
    <updated>2015-05-14T13:10:05.000Z</updated>
    <content type="html"><![CDATA[<p>最近查看了下ES6的某些特性，最让博主不不解的是Generator，这个特性。一直在考虑，这鬼东东是干嘛用的？哥有Promise就好了，为嘛还要你这东东？理解起来还忒麻烦，还得配合thunk或者promise来使用。不过存在即合理，虽然不是特别理解ES6，出这个的用意。<br>我们先看下阮一峰《es6入门》的一段解释</p>
<blockquote>
<p>可以把它理解成一个函数的内部状态的遍历器，每调用一次，函数的内部状态发生一次改变（可以理解成发生某些事件）。ES6引入Generator函数，作用就是可以完全控制函数的内部状态的变化，依次遍历这些状态。<br>在形式上，Generator是一个普通函数，但是有两个特征。一是，function命令与函数名之间有一个星号；二是，函数体内部使用yield语句，定义遍历器的每个成员，即不同的内部状态（yield语句在英语里的意思就是“产出”）。</p>
</blockquote>
<h1 id="Generator">Generator</h1><p>Generator函数在遇到yield的时候，就会暂停执行之后的内容。这挺起来挺别扭，看代码吧。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">gen</span> = function* (x) &#123;</span><br><span class="line">	<span class="keyword">var</span> a = yield x+1;</span><br><span class="line">	<span class="keyword">var</span> b = yield a+2;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">g</span> = <span class="keyword">gen</span>(2);</span><br><span class="line"><span class="keyword">g</span>.next();<span class="comment">//返回&#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="keyword">g</span>.next(4); <span class="comment">//返回&#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="keyword">g</span>.next();  <span class="comment">//返回 &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>咋们来解释下上面的代码：</p>
<ol>
<li>先运行gen(2),得到一个迭代器g</li>
<li>运行g.next(),系统执行x+1(x=2),返回{value: 3, done: false}</li>
<li>运行g.next(4),把4赋值给a，然后返回{value: 6, done: false}，不要问为什么a不是等于3，反正语法就是这样。</li>
<li>运行g.next(),返回{value: undefined, done: true}，因为我们没有为b赋值，所以就是undefined</li>
</ol>
<p>我们可以发现上面是我们手动一步步执行的。也就是上面说的，Generator遇到yield的时候会挂起，暂停执行。<br>这里不讨论Generator当做普通迭代器的用法，这里讨论的是如何使用Generator来让异步编程看起来更优美。所以这里，我们必须先解释下<strong>Thunk</strong>这东西。<br><a id="more"></a></p>
<h1 id="Thunk">Thunk</h1><p>先看一段代码<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(fileName, <span class="keyword">callback</span>); <span class="comment">//正常版本的readFile</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFileThunk = (<span class="function"><span class="keyword">function</span><span class="params">(fileName)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(callback)</span> </span>&#123; <span class="comment">//返回Thunk函数</span></span><br><span class="line">		<span class="keyword">return</span> fs.readFile(fileName, <span class="keyword">callback</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;)(fileName);</span><br></pre></td></tr></table></figure></p>
<p>上面那段代码中的匿名函数就是<strong>Thunk</strong>函数。现在就能解释Thunk函数的意思了。</p>
<blockquote>
<p>任何函数，只要参数中包含有回调，我们就能转化成单参数的函数，这个函数只接受回调函数作为参数，例如上面的<code>readFileThunk</code>,这个单参数的函数就叫做Thunk函数。</p>
</blockquote>
<p>OK，解释完这个之后，可以真正进入Generator的异步编程了。</p>
<h1 id="Generator异步编程">Generator异步编程</h1><p>直接看代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span><span class="params">(fileName)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(callback)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> fs.readFile(fileName, callback);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>*<span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> r1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/hosts'</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(r1.toString());</span><br><span class="line">	<span class="keyword">var</span> r2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(r2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们先不管是不是异步编程，上面gen这个Generator函数的函数体看起来是不是非常的像在做同步编程<br>但实际上做的是异步编程，我们看下面的手动执行解析就能很清楚的知道执行机制是什么。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手动执行文件读取，更加直观的看Generator是怎么执行的</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">g</span> = <span class="keyword">gen</span>();</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="keyword">g</span>.next();</span><br><span class="line">r1.value(function(<span class="keyword">err</span>, data) &#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">err</span>) throw <span class="keyword">err</span>;</span><br><span class="line">	<span class="keyword">var</span> r2 = <span class="keyword">g</span>.next(data); <span class="comment">//把data值赋值给gen中的r1</span></span><br><span class="line">	r2.value(function(<span class="keyword">err</span>, data) &#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">err</span>) throw <span class="keyword">err</span>;</span><br><span class="line">		<span class="keyword">g</span>.next(data); <span class="comment">//把data值赋值给gen中的r2</span></span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>OK，如果有很多异步读取文件的操作，我们总不能手动一个一个写吧，那也实在太low了。所以牛逼的TJ大神出了CO这个库</p>
<h1 id="CO">CO</h1><p>使用了CO是个神马感觉呢？先看代码<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> co = <span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">'thunkify'</span>); <span class="comment">//TJ大神写的，把函数转换成Thunk的库</span></span><br><span class="line"><span class="keyword">var</span> readFile = thunkify(fs.readFile);</span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* <span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> r1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/hosts'</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(r1.toString());</span><br><span class="line">	<span class="keyword">var</span> r2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(r2.toString());</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span><span class="params">(err, data)</span> </span>&#123; <span class="comment">//匿名回调函数，每次读取完文件后，都会执行一遍</span></span><br><span class="line">	<span class="built_in">console</span>.log(err, data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>看了上面的代码，是不是有种惊讶的感觉，怎么能够这么精炼，是的就是这么精炼。<br>来看看精简版的co实现<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> co = function(generator) &#123;</span><br><span class="line">	<span class="keyword">return</span> function(callback) &#123;</span><br><span class="line">		<span class="keyword">var</span> gen = generator();</span><br><span class="line">		function next(err, <span class="literal">result</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(err) &#123;</span><br><span class="line">				<span class="keyword">return</span> callback(err);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">var</span> step = gen.next(<span class="literal">result</span>);</span><br><span class="line">			<span class="keyword">if</span>(!step.done) &#123; //如果未完成</span><br><span class="line">				step.value(next);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				callback(null, step.value);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		next();</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>很精炼的几句代码就完成了很牛逼的工作。上面代码是网上别人提炼出来的。<br>现在co已经支持promise了，博主写了段代码，来猜测co的promise实现，不知道正不正确，等鄙人拜读co源码之后再确定下，现在先放出鄙人写的代码。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function co(generator) &#123;</span><br><span class="line">	<span class="keyword">var</span> deferred = $.<span class="type">Deferred</span>();</span><br><span class="line">	<span class="keyword">var</span> gen = generator();</span><br><span class="line">	function next(err, <span class="literal">result</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(err) &#123;</span><br><span class="line">			deferred.reject(err);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">var</span> step = gen.next(<span class="literal">result</span>);</span><br><span class="line">		<span class="keyword">if</span>(!step.done) &#123;</span><br><span class="line">			gen.value(next);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			deferred.resolve(<span class="literal">result</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	next();</span><br><span class="line">	<span class="keyword">return</span> deferred;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近查看了下ES6的某些特性，最让博主不不解的是Generator，这个特性。一直在考虑，这鬼东东是干嘛用的？哥有Promise就好了，为嘛还要你这东东？理解起来还忒麻烦，还得配合thunk或者promise来使用。不过存在即合理，虽然不是特别理解ES6，出这个的用意。<br>我们先看下阮一峰《es6入门》的一段解释</p>
<blockquote>
<p>可以把它理解成一个函数的内部状态的遍历器，每调用一次，函数的内部状态发生一次改变（可以理解成发生某些事件）。ES6引入Generator函数，作用就是可以完全控制函数的内部状态的变化，依次遍历这些状态。<br>在形式上，Generator是一个普通函数，但是有两个特征。一是，function命令与函数名之间有一个星号；二是，函数体内部使用yield语句，定义遍历器的每个成员，即不同的内部状态（yield语句在英语里的意思就是“产出”）。</p>
</blockquote>
<h1 id="Generator">Generator</h1><p>Generator函数在遇到yield的时候，就会暂停执行之后的内容。这挺起来挺别扭，看代码吧。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">gen</span> = function* (x) &#123;</span><br><span class="line">	<span class="keyword">var</span> a = yield x+1;</span><br><span class="line">	<span class="keyword">var</span> b = yield a+2;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">g</span> = <span class="keyword">gen</span>(2);</span><br><span class="line"><span class="keyword">g</span>.next();<span class="comment">//返回&#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="keyword">g</span>.next(4); <span class="comment">//返回&#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="keyword">g</span>.next();  <span class="comment">//返回 &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>咋们来解释下上面的代码：</p>
<ol>
<li>先运行gen(2),得到一个迭代器g</li>
<li>运行g.next(),系统执行x+1(x=2),返回{value: 3, done: false}</li>
<li>运行g.next(4),把4赋值给a，然后返回{value: 6, done: false}，不要问为什么a不是等于3，反正语法就是这样。</li>
<li>运行g.next(),返回{value: undefined, done: true}，因为我们没有为b赋值，所以就是undefined</li>
</ol>
<p>我们可以发现上面是我们手动一步步执行的。也就是上面说的，Generator遇到yield的时候会挂起，暂停执行。<br>这里不讨论Generator当做普通迭代器的用法，这里讨论的是如何使用Generator来让异步编程看起来更优美。所以这里，我们必须先解释下<strong>Thunk</strong>这东西。<br>]]>
    
    </summary>
    
      <category term="ES6" scheme="http://blog.angrytoro.com/tags/ES6/"/>
    
      <category term="JavaScript" scheme="http://blog.angrytoro.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何编写node命令]]></title>
    <link href="http://blog.angrytoro.com/2015/04/28/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99node%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.angrytoro.com/2015/04/28/如何编写node命令/</id>
    <published>2015-04-28T12:57:28.000Z</published>
    <updated>2015-04-28T14:30:14.000Z</updated>
    <content type="html"><![CDATA[<p>平时我们都是用别人编写好的nodejs命令，某些时候，我们也想写个命令玩下，咋整。好了，接下去这边流水账就是从头告诉你怎么写一个node命令的。<br>要写一个nodejs命令，首先要储备4个知识点。</p>
<ol>
<li>Commander模块</li>
<li>怎么告诉nodejs，这是一条命令</li>
<li>如何调试node</li>
<li>如何发布node插件<h1 id="Commander">Commander</h1>TJ大神写的<a href="https://github.com/tj/commander.js" target="_blank" rel="external">commander</a>（也有Ruby版本），很方便大伙儿写命令，本人就不在这儿翻译commander的说明文档了，大家自己去查看。这里给个官方例子，看看有多方便。<figure class="highlight rsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var program = require(<span class="string">'commander'</span>);</span><br><span class="line"></span><br><span class="line">program</span><br><span class="line">  .version(<span class="string">'0.0.1'</span>)</span><br><span class="line">  .<span class="built_in">option</span>(<span class="string">'-p, --peppers'</span>, <span class="string">'Add peppers'</span>)</span><br><span class="line">  .<span class="built_in">option</span>(<span class="string">'-P, --pineapple'</span>, <span class="string">'Add pineapple'</span>)</span><br><span class="line">  .<span class="built_in">option</span>(<span class="string">'-b, --bbq-sauce'</span>, <span class="string">'Add bbq sauce'</span>)</span><br><span class="line">  .<span class="built_in">option</span>(<span class="string">'-c, --cheese [type]'</span>, <span class="string">'Add the specified type of cheese [marble]'</span>, <span class="string">'marble'</span>)</span><br><span class="line">  .parse(process.argv);</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">'you ordered a pizza with:'</span>);</span><br><span class="line"><span class="keyword">if</span> (program.peppers) console.<span class="built_in">log</span>(<span class="string">'  - peppers'</span>);</span><br><span class="line"><span class="keyword">if</span> (program.pineapple) console.<span class="built_in">log</span>(<span class="string">'  - pineapple'</span>);</span><br><span class="line"><span class="keyword">if</span> (program.bbqSauce) console.<span class="built_in">log</span>(<span class="string">'  - bbq'</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">'  - %s cheese'</span>, program.cheese);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="如何配置package-json">如何配置package.json</h1><p>我们要在package.json中添加一个字段<code>bin</code><br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">"name"</span>: <span class="string">"xxx"</span>, //命令的名字（一定是npm里面没有的）</span><br><span class="line">  	<span class="string">"version"</span>: <span class="string">"0.0.1"</span>, //版本号</span><br><span class="line">  	<span class="string">"bin"</span>: <span class="string">"./bin/yourCommander"</span>, //命令存放的位置</span><br><span class="line">  	<span class="keyword">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>yourCommander文件中需要添加一行<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/usr/bin/env node</span></span><br></pre></td></tr></table></figure></p>
<p>例如我写的命令<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env node</span></span><br><span class="line"><span class="keyword">require</span>(<span class="string">'../index.js'</span>); <span class="regexp">//</span>程序的入口</span><br></pre></td></tr></table></figure></p>
<p>假设我们采用全局安装<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> xxx -g</span><br></pre></td></tr></table></figure></p>
<p>那么我们就能够直接在终端里面输入<code>xxx -oo</code>（只是举例）来调用我们的命令。</p>
<h1 id="如何调试node">如何调试node</h1><p>好吧，我只认<code>node-inspector</code>。先全局安装<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> node-inspector -g</span><br></pre></td></tr></table></figure></p>
<p>然后直接运行<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node-<span class="keyword">debug</span> xxx/xxx</span><br></pre></td></tr></table></figure></p>
<p>xxx/xxx是bin文件的路径，这样我们就能在chrome浏览器的控制面板上看到相应的断点了。</p>
<h1 id="如何发布node插件">如何发布node插件</h1><p>OK，当我们写好了命令，那要怎么发布呢？<br>最好是先本地安装一下，实验看看能不能正确运行<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install <span class="tag">&lt;<span class="title">本地路径</span>&gt;</span> -g</span><br></pre></td></tr></table></figure></p>
<p>然后就能测试自己边写的命令。如果正确执行，那么我们就能够发布到npm上<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">npm</span> adduser <span class="regexp">//</span>创建<span class="built_in">npm</span>账户</span><br></pre></td></tr></table></figure></p>
<p>执行此命令后，会依次出现输入用户名、Email、密码的提示，输入好之后等待一会儿就可以了。<br>接下去就是发布了<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm publish <span class="tag">&lt;<span class="title">本地路径</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果要更新程序包，只要修改一下package.json中的版本号，再重新执行发布命令就可以了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>平时我们都是用别人编写好的nodejs命令，某些时候，我们也想写个命令玩下，咋整。好了，接下去这边流水账就是从头告诉你怎么写一个node命令的。<br>要写一个nodejs命令，首先要储备4个知识点。</p>
<ol>
<li>Commander模块</li>
<li>怎么]]>
    </summary>
    
      <category term="NodeJS" scheme="http://blog.angrytoro.com/tags/NodeJS/"/>
    
      <category term="JavaScript" scheme="http://blog.angrytoro.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[es6编译成es5]]></title>
    <link href="http://blog.angrytoro.com/2015/04/19/es6%E7%BC%96%E8%AF%91%E6%88%90es5/"/>
    <id>http://blog.angrytoro.com/2015/04/19/es6编译成es5/</id>
    <published>2015-04-19T02:03:39.000Z</published>
    <updated>2015-04-19T07:28:31.000Z</updated>
    <content type="html"><![CDATA[<p>这ES6变准还没完成，前端界已经蠢蠢欲动。看了下ES6的语法，确实是比ES5好非常的多。难怪前端界那么兴奋。小编本着折腾死的精神，尝试了下谷歌开发的编译工具<a href="https://github.com/google/traceur-compiler" target="_blank" rel="external">traceur</a>和比较多人用的<a href="https://babeljs.io/" target="_blank" rel="external">babel</a>。发现两个编译工具都有各自的缺点。</p>
<h1 id="traceur和babel编译器的优缺点">traceur和babel编译器的优缺点</h1><ul>
<li>traceur: 这货编译成的代码的<strong>可读性还是挺好的</strong>。不过比较坑爹的是，traceur需要引入<code>traceur-runtime.js</code>这个运行时脚本，并且在运行时会出现一些莫名的错误。估计是还不成熟。<br><img src="/img/traceur编译.jpg" alt="traceur编译"><a id="more"></a></li>
<li>babel: 看了<a href="https://babeljs.io/" target="_blank" rel="external">官网</a>，使用这货的牛逼公司还挺多。编译后运行没有什么大问题,就是编译后代码可读性比较欠缺，它有个牛逼的功能是支持commonjs。如果我们用browserify,那就更欢乐了。<br><img src="/img/babel编译.jpg" alt="babel编译"></li>
</ul>
<h1 id="compjs编译器">compjs编译器</h1><p>折腾了一阵子，写了个node工具<a href="https://github.com/angrytoro/6to5" target="_blank" rel="external">compjs</a>，整合了traceur和babel，让compjs支持traceur和babel编译，目前的命令还比较简单，只支持最基本的编译（将源文件夹下的文件，编译到输出文件夹中）。<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ compjs --<span class="keyword">help</span> <span class="comment">//查看帮助</span></span><br></pre></td></tr></table></figure></p>
<p>进入到相应项目文件夹下，输入<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>compjs</span><br></pre></td></tr></table></figure></p>
<p>就会把相应的es6文件，编译到gsrc文件夹下，当然也可以自己指定编译后的位置。<br>有兴趣的朋友可以安装下试试。也可以贡献<a href="https://github.com/angrytoro/6to5" target="_blank" rel="external">compjs</a>源码。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这ES6变准还没完成，前端界已经蠢蠢欲动。看了下ES6的语法，确实是比ES5好非常的多。难怪前端界那么兴奋。小编本着折腾死的精神，尝试了下谷歌开发的编译工具<a href="https://github.com/google/traceur-compiler">traceur</a>和比较多人用的<a href="https://babeljs.io/">babel</a>。发现两个编译工具都有各自的缺点。</p>
<h1 id="traceur和babel编译器的优缺点">traceur和babel编译器的优缺点</h1><ul>
<li>traceur: 这货编译成的代码的<strong>可读性还是挺好的</strong>。不过比较坑爹的是，traceur需要引入<code>traceur-runtime.js</code>这个运行时脚本，并且在运行时会出现一些莫名的错误。估计是还不成熟。<br><img src="/img/traceur编译.jpg" alt="traceur编译">]]>
    
    </summary>
    
      <category term="NodeJS" scheme="http://blog.angrytoro.com/tags/NodeJS/"/>
    
      <category term="JavaScript" scheme="http://blog.angrytoro.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Chrome浏览器Network面板]]></title>
    <link href="http://blog.angrytoro.com/2015/03/30/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8Network%E9%9D%A2%E6%9D%BF/"/>
    <id>http://blog.angrytoro.com/2015/03/30/Chrome浏览器Network面板/</id>
    <published>2015-03-30T15:12:18.000Z</published>
    <updated>2015-04-01T15:10:24.000Z</updated>
    <content type="html"><![CDATA[<p>前端程序员在调试页面的时候，最常用到的几个面板：Elements, Network, Sources。其中比较让新手疑惑的是Network面板。那些时间线分别代表什么呢？每个字段，分别代表神马意思呢？</p>
<h1 id="Resource_Timing_API">Resource Timing API</h1><p>这个面板使用<a href="http://www.w3.org/TR/resource-timing/" target="_blank" rel="external">Resource Timing API</a>来计算相应的数据。只要对这个api有足够的了解，我们也能做出跟Chrome Network面板一样的时间轴。由于本文不是主要介绍这个API，因此，如果大家对这个api感兴趣，那么请参考<a href="http://www.w3cfuns.com/article-5598442-1-1.html" target="_blank" rel="external">Navigation Timing 测试网页加载速度</a>，这里面做了非常详细的解释，有了这个API，我们还能考虑通过这个API做些网站性能数据分析(题外话)。<br><img src="/img/resource-timing-overview.png" alt="network timing data points"><br>咋们看看每个请求，都包含有哪些数据。在控制台输入<code>performance.getEntries()[0]</code><br><a id="more"></a><br><img src="/img/performance.getEntries.png" alt="这个api记录的第一个请求的数据"><br>有这些数据，我们可以做详细的网站性能统计。<br>这里只记录了每个请求的每个节点所花的时间，那么有没有接口记录整个网页的加载详情呢。有的，<code>performance.timing</code>这个接口记录了整个网页加载的详细时间数据。<br><img src="/img/performance.timing.png" alt="performance.timing"></p>
<h1 id="Timing_details_tab">Timing details tab</h1><p>当我们在测试某个接口，或者某个资源的加载速度时，我们最常用的就是<strong>Timing details tab</strong>这个东东了，先看下，它到底是什么，然后咋们在来解释每个字段的意思。<br><img src="/img/Timing details tab.png" alt="Timing details tab"><br>这个截图没有包含<strong>Timing details tab</strong>的所有字段。</p>
<h2 id="字段解释">字段解释</h2><ul>
<li><strong>Stalled/Blocking:</strong>是浏览器得到发出请求指令，到请求可以发出所等待的时间.包括等待代理协商等待的时间，除此之外还有浏览器等待可复用的连接的时间（Chrome下，同一个域名下最多可同时并行6个请求，不同浏览器的可同时并发请求连接数量不一样，详情请参考<a href="http://www.zhihu.com/question/20474326" target="_blank" rel="external">浏览器允许的并发请求资源数是什么意思</a>）</li>
<li><strong>Proxy Negotiation:</strong>链接代理服务器所花的协商时间</li>
<li><strong>DNS Lookup:</strong>dns查询所花的时间(像刚才的截图，我们可以发现这个网站花在dns查找的时间太多了)</li>
<li><strong>Initial Connection / Connecting:</strong>TCP握手所花的时间</li>
<li><strong>SSL:</strong>如果是https请求，那么浏览器还要话费SSL握手时间。</li>
<li><strong>Request Sent / Sending:</strong>请求发送完成所花的时间</li>
<li><strong>Waiting (TTFB):</strong>请求发出后，到接收第一个字节所花的时间（在网速稳定的情况下，如果花的时间很长，那么就要检查下是程序写得有问题还是服务器出问题了）</li>
<li><strong>Content Download / Downloading:</strong>接收服务器传来的数据所花的时间<br>以上所有时间加起来就是这个请求所花的时间。如果网页加载慢，从这里我们大概可以检查哪个请求有异常。<h1 id="如何查看我们网页首屏加载时间">如何查看我们网页首屏加载时间</h1>先看一张图片<br><img src="/img/页面加载时间.png" alt="页面加载时间"><br>这里有两个参数<strong>DOMContentLoaded</strong>和<strong>load</strong><br><strong>DOMContentLoaded:</strong>表示 DOM 与 CSSOM 皆已准备就绪(很多 JavaScript 框架会在执行它们自己的逻辑前等待这个事件的触发)。这个所花时间越长，证明这个页面越复杂，或者你的代码有问题。首屏对用户很重要，所以这个时间不要太长。<br><strong>load:</strong>表示页面所需的资源已经都加载了，如果这个花很长时间，该看看哪个坑爹的资源出问题了。<br>目前看过对首屏优化做得最好的之一是亚马逊，那速度简直是变态的快。<h1 id="总结">总结</h1>当我们网站加载速度慢的时候，看看这个tab，检查下哪些地方可以优化。</li>
</ul>
<h1 id="参考">参考</h1><blockquote>
<p><a href="https://developer.chrome.com/devtools/docs/network" target="_blank" rel="external">Evaluating network performance</a><br><a href="http://www.w3.org/TR/resource-timing/" target="_blank" rel="external">Resource Timing</a><br><a href="http://www.w3cfuns.com/article-5598442-1-1.html" target="_blank" rel="external">Navigation Timing 测试网页加载速度</a><br><a href="http://www.th7.cn/web/html-css/201311/14802.shtml" target="_blank" rel="external">初探performance.timing API</a><br><a href="http://segmentfault.com/q/1010000002399481/a-1020000002399855" target="_blank" rel="external">chrome的timeline的问题？</a><br><a href="http://www.zhihu.com/question/20474326" target="_blank" rel="external">浏览器允许的并发请求资源数是什么意思？</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>前端程序员在调试页面的时候，最常用到的几个面板：Elements, Network, Sources。其中比较让新手疑惑的是Network面板。那些时间线分别代表什么呢？每个字段，分别代表神马意思呢？</p>
<h1 id="Resource_Timing_API">Resource Timing API</h1><p>这个面板使用<a href="http://www.w3.org/TR/resource-timing/">Resource Timing API</a>来计算相应的数据。只要对这个api有足够的了解，我们也能做出跟Chrome Network面板一样的时间轴。由于本文不是主要介绍这个API，因此，如果大家对这个api感兴趣，那么请参考<a href="http://www.w3cfuns.com/article-5598442-1-1.html">Navigation Timing 测试网页加载速度</a>，这里面做了非常详细的解释，有了这个API，我们还能考虑通过这个API做些网站性能数据分析(题外话)。<br><img src="/img/resource-timing-overview.png" alt="network timing data points"><br>咋们看看每个请求，都包含有哪些数据。在控制台输入<code>performance.getEntries()[0]</code><br>]]>
    
    </summary>
    
      <category term="chrome" scheme="http://blog.angrytoro.com/tags/chrome/"/>
    
      <category term="工具" scheme="http://blog.angrytoro.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对于JavaScript中继承的思考]]></title>
    <link href="http://blog.angrytoro.com/2015/03/24/%E5%AF%B9%E4%BA%8EJavaScript%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://blog.angrytoro.com/2015/03/24/对于JavaScript中继承的思考/</id>
    <published>2015-03-23T16:25:26.000Z</published>
    <updated>2015-03-24T15:04:06.000Z</updated>
    <content type="html"><![CDATA[<p>先附上一份代码让大家思考，直接看代码，猜猜最终执行的结果会是什么。<br>如果哪位能直接从代码中看出执行结果，那么这人的工资肯定不低于10K。请看全文解释<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">($)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> super_ = <span class="function"><span class="keyword">function</span><span class="params">(methodName, args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> method = <span class="keyword">this</span>.superClass_.prototype[methodName];</span><br><span class="line">		<span class="keyword">if</span>(method &amp;&amp; <span class="keyword">typeof</span> method === <span class="string">'function'</span>) &#123;</span><br><span class="line">			method.call(<span class="keyword">this</span>, args);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">  	$.inherit = <span class="function"><span class="keyword">function</span><span class="params">(subClass, superClass)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">var</span> temp = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	    temp.prototype = superClass.prototype;</span><br><span class="line">	    <span class="keyword">var</span> subPro = <span class="keyword">new</span> temp();</span><br><span class="line">	    subPro.constructor = subClass;</span><br><span class="line">	    subPro.super_ = super_;</span><br><span class="line">	    subPro.superClass_ = superClass;</span><br><span class="line">	    subClass.prototype = subPro;</span><br><span class="line">  	&#125;;</span><br><span class="line">&#125;)(jQuery);</span><br><span class="line"><span class="keyword">var</span> Super = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = <span class="string">'Super'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">$.extend(Super.prototype, &#123;</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Super'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> Sub1 = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = <span class="string">'Sub1'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">$.inherit(Sub1, Super);</span><br><span class="line">$.extend(Sub1.prototype, &#123;</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.super_(<span class="string">'say'</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Sub1'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> Sub1().say();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'========'</span>);</span><br><span class="line"><span class="keyword">var</span> Sub2 = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = <span class="string">'Sub2'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">$.inherit(Sub2, Sub1);</span><br><span class="line">$.extend(Sub2.prototype, &#123;</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.super_(<span class="string">'say'</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Sub2'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> Sub2().say();</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>这份代码的最终执行结果是<strong>死循环</strong>。<img src="/img/对于JavaScript中继承的思考-执行结果.png" alt="执行结果"><br>这份代码的目的是实现<code>JavaScript</code>的继承，并且希望子类能通过<code>this.super_(methodName, arguments)</code>来实现调用父元素的相同方法。</p>
<h1 id="代码解释">代码解释</h1><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(function($) &#123;</span><br><span class="line">	<span class="keyword">var</span> super_ = function(methodName, args) &#123;</span><br><span class="line">		<span class="keyword">var</span> <span class="keyword">method</span> = this.superClass_.prototype[methodName];</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">method</span> &amp;&amp; typeof <span class="keyword">method</span> === 'function') &#123;</span><br><span class="line">			<span class="keyword">method</span>.call(this, args);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">  	$.inherit = function(subClass, superClass) &#123;</span><br><span class="line">	    <span class="keyword">var</span> temp = function() &#123;&#125;;</span><br><span class="line">	    temp.prototype = superClass.prototype;</span><br><span class="line">	    <span class="keyword">var</span> subPro = new temp();</span><br><span class="line">	    subPro.constructor = subClass;</span><br><span class="line">	    subPro.super_ = super_;</span><br><span class="line">	    subPro.superClass_ = superClass;</span><br><span class="line">	    subClass.prototype = subPro;</span><br><span class="line">  	&#125;;</span><br><span class="line">&#125;)(jQuery);</span><br></pre></td></tr></table></figure>
<p>这段代码主要实现了一个函数<code>$.inherit</code>,这个函数应用于<code>JavaScript</code>的继承。里面的代码是<code>JavaScript</code>最经典的继承实现方案。<br>不过呢，有个不足的地方，那就是，这段代码还想实现<code>this.super_(methodName, arguments)</code>。这个方法类似于OO语言,某种便捷的语法糖去调用基类中被子类覆盖的方法，例如Java中<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class A &#123;</span><br><span class="line">   <span class="type">void</span> <span class="keyword">method</span>() &#123;</span><br><span class="line">      <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"A"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class B &#123;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">method</span>() &#123;</span><br><span class="line">        super.<span class="keyword">method</span>();</span><br><span class="line">        <span class="type">System</span>.<span class="keyword">out</span>.println(<span class="string">"B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们这里的实现方法，如果说是继承后，不重写父级方法，或者在重写父级方法的时候，不调用<code>this.super_(methodName, arguments)</code>，那么没有神马问题，你可以各种深度继承<code>B继承A，C继承B，D继承C</code>，这些都没有问题。<br><strong>可是！</strong>这玩意儿没法没法让我们实现类似最上面那段代码的继承方式，<code>Sub1继承Supper，Sub2继承Sub1</code>，然后<code>Sub1,Sub2</code>都重写了<code>say</code>方法，并且<code>say</code>方法都调用了<code>this.super_(methodName, arguments)</code>，这个时候要出现死循环了.在调用<code>new Sub2().say();</code>的时，会先去调用<code>this.super_(&#39;say&#39;, arguments);</code>，然后执行<code>Sub1</code>里面的<code>say</code>，这个时候又执行<code>this.super_(&#39;say&#39;, arguments);</code>，问题就是出在这里，这个<code>this</code>对象可是<code>Sub2</code>的对象，也就是说<code>this.superClass_.prototype[methodName];</code>这段代码相当于<code>Sub1.prototype.say</code>，然后一直在这里循环。</p>
<h1 id="寻求解决方案">寻求解决方案</h1><p>如果那位有牛逼的解决方案，请告诉各位苦逼程序员，谢谢~~o(&gt;_&lt;)o ~~。</p>
<h1 id="参考">参考</h1><blockquote>
<p><a href="http://efe.baidu.com/blog/oo-super-syntax-in-javascript/" target="_blank" rel="external">在 Javascript 中实现调用父类同名方法的语法糖(this._super())</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>先附上一份代码让大家思考，直接看代码，猜猜最终执行的结果会是什么。<br>如果哪位能直接从代码中看出执行结果，那么这人的工资肯定不低于10K。请看全文解释<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">($)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> super_ = <span class="function"><span class="keyword">function</span><span class="params">(methodName, args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> method = <span class="keyword">this</span>.superClass_.prototype[methodName];</span><br><span class="line">		<span class="keyword">if</span>(method &amp;&amp; <span class="keyword">typeof</span> method === <span class="string">'function'</span>) &#123;</span><br><span class="line">			method.call(<span class="keyword">this</span>, args);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">  	$.inherit = <span class="function"><span class="keyword">function</span><span class="params">(subClass, superClass)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">var</span> temp = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">	    temp.prototype = superClass.prototype;</span><br><span class="line">	    <span class="keyword">var</span> subPro = <span class="keyword">new</span> temp();</span><br><span class="line">	    subPro.constructor = subClass;</span><br><span class="line">	    subPro.super_ = super_;</span><br><span class="line">	    subPro.superClass_ = superClass;</span><br><span class="line">	    subClass.prototype = subPro;</span><br><span class="line">  	&#125;;</span><br><span class="line">&#125;)(jQuery);</span><br><span class="line"><span class="keyword">var</span> Super = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = <span class="string">'Super'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">$.extend(Super.prototype, &#123;</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Super'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> Sub1 = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = <span class="string">'Sub1'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">$.inherit(Sub1, Super);</span><br><span class="line">$.extend(Sub1.prototype, &#123;</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.super_(<span class="string">'say'</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Sub1'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> Sub1().say();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'========'</span>);</span><br><span class="line"><span class="keyword">var</span> Sub2 = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.name = <span class="string">'Sub2'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">$.inherit(Sub2, Sub1);</span><br><span class="line">$.extend(Sub2.prototype, &#123;</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.super_(<span class="string">'say'</span>, <span class="built_in">arguments</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Sub2'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> Sub2().say();</span><br></pre></td></tr></table></figure></p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.angrytoro.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为了运行fekit sync，在服务器配置rsync的时候遇到的问题]]></title>
    <link href="http://blog.angrytoro.com/2015/03/12/%E4%B8%BA%E4%BA%86%E8%BF%90%E8%A1%8Cfekit-sync%EF%BC%8C%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AErsync%E7%9A%84%E6%97%B6%E5%80%99%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.angrytoro.com/2015/03/12/为了运行fekit-sync，在服务器配置rsync的时候遇到的问题/</id>
    <published>2015-03-12T14:40:48.000Z</published>
    <updated>2015-03-12T14:48:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="问题一、sudo：抱歉，您必须拥有一个终端来执行_sudo">问题一、<code>sudo：抱歉，您必须拥有一个终端来执行 sudo</code></h2><p>在执行<code>fekit sync</code>的时候遇到这个问题。解决办法</p>
<blockquote>
<p>以root权限进入服务器，编辑<code>/etc/sudoers</code>，注释掉 <code>Default requiretty</code>这 一行</p>
</blockquote>
<h2 id="问题二、sudo:_no_tty_present_and_no_askpass_program_specified">问题二、<code>sudo: no tty present and no askpass program specified</code></h2><p>第一个问题解决后运行时曝出了这个错误，解决办法</p>
<blockquote>
<p>以root权限进入服务器，编辑<code>/etc/sudoers</code>，设置<code>Defaults visiblepw</code></p>
</blockquote>
<h2 id="问题三、Error:_Command_failed:_[sudo]_password_for_xxx">问题三、<code>Error: Command failed: [sudo] password for xxx</code></h2><p>上面的解决后，在运行<code>fekit sync</code>还是会爆出这个错误，其中<code>xxx</code>是用户名。那是因为你配置了免密码登录，但是普通用户在运行<code>sudo</code>的时候还是需要输入密码，这导致了这个错误的出现。解决办法</p>
<blockquote>
<p>以root权限进入服务器，输入<code>visudo</code>，然后有几种方法</p>
<ol>
<li>添加<code>yourname ALL=(ALL) NOPASSWD: ALL</code>——这个意思是<code>yourname</code>这个用户可以免密码<code>sudo</code>.</li>
<li><code>%groupname ALL=(ALL) NOPASSWD: ALL</code> ——这个意思是<code>groupname</code>这个组的用户都可以免密码<code>sudo</code>，那么多人都可以免密码<code>sudo</code>，这会带来安全问题的。</li>
<li><code>%groupname ALL= NOPASSWD:/usr/bin/rsync</code>——只为<code>rsync</code>开了sudo的免密码。相对安全。</li>
</ol>
</blockquote>
<h1 id="总结">总结</h1><p>按照上面的解决办法绝对可以成功免密码rsync。谢谢大家。</p>
<h2 id="配置免密码fekit_sync注意事项">配置免密码fekit sync注意事项</h2><blockquote>
<ol>
<li>用户需要配置免密码ssh</li>
<li>用户需要有sudo权限</li>
</ol>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="问题一、sudo：抱歉，您必须拥有一个终端来执行_sudo">问题一、<code>sudo：抱歉，您必须拥有一个终端来执行 sudo</code></h2><p>在执行<code>fekit sync</code>的时候遇到这个问题。解决办法</p>
<block]]>
    </summary>
    
      <category term="linux" scheme="http://blog.angrytoro.com/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何对服务器进行免密码登录配置]]></title>
    <link href="http://blog.angrytoro.com/2015/03/12/%E5%A6%82%E4%BD%95%E5%AF%B9%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.angrytoro.com/2015/03/12/如何对服务器进行免密码登录配置/</id>
    <published>2015-03-12T04:32:33.000Z</published>
    <updated>2015-03-18T13:42:08.000Z</updated>
    <content type="html"><![CDATA[<h1 id="用户组操作">用户组操作</h1><p>命令解释<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grooupadd xxx <span class="comment">//新建用户组</span></span><br><span class="line">chgrp xxx -R fileName <span class="comment">//将某个文件夹(fileName)及其下面的所有文件的属组设置为<span class="label">xxx(用户组)</span></span></span><br><span class="line">gpasswd -<span class="tag">a</span> user groupName <span class="comment">//将用户user 添加到组groupName</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="用户操作">用户操作</h1><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd xxx -<span class="keyword">g</span> groupName<span class="comment">//新增用户<span class="label">xxx并把它划分到groupName这个组</span></span></span><br><span class="line">passwd xxx <span class="comment">//为<span class="label">xxx用户设置密码</span></span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="新增用户并赋予某个组的脚本">新增用户并赋予某个组的脚本</h1><p>假设我已创建fontend组，那么创建一个useradd.sh脚本，内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="shebang">#!/bin/bash</span></span><br><span class="line">useradd <span class="variable">$1</span> -g fontend</span><br><span class="line">passwd <span class="variable">$1</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以这么执行<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sh</span> useradd.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure></p>
<p>也可以取一个别名<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> addFontendUser = <span class="string">'sh useradd.sh'</span></span><br></pre></td></tr></table></figure></p>
<p>那么之后我们就可以直接在系统执行<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addFontendUser</span><br></pre></td></tr></table></figure></p>
<p>来添加fontend组的用户了</p>
<h1 id="免密码登录">免密码登录</h1><p>假设创建了个用户abc，那么用abc登录服务器<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#cd</span> ~</span><br><span class="line"><span class="id">#mkdir</span> <span class="class">.ssh</span></span><br><span class="line"><span class="id">#chmod</span> <span class="number">700</span> <span class="class">.ssh</span></span><br><span class="line"><span class="id">#cd</span> <span class="class">.ssh</span></span><br><span class="line"><span class="id">#vi</span> authorized_keys <span class="comment">//将你pc的公钥放进去</span></span><br><span class="line"><span class="id">#chmod</span> <span class="number">655</span> authorized_keys</span><br></pre></td></tr></table></figure></p>
<p>设置完，退出登录，然后就可以享受免密码登录了<br>注意事项</p>
<blockquote>
<ol>
<li>必须设置.ssh的权限为700</li>
<li>必须设置authorized_keys的权限为655（有人说644也行，不太懂）</li>
</ol>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="用户组操作">用户组操作</h1><p>命令解释<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grooupadd xxx <span class="comment">//新建用户组</span></span><br><span class="line">chgrp xxx -R fileName <span class="comment">//将某个文件夹(fileName)及其下面的所有文件的属组设置为<span class="label">xxx(用户组)</span></span></span><br><span class="line">gpasswd -<span class="tag">a</span> user groupName <span class="comment">//将用户user 添加到组groupName</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h1 id="用户操作">用户操作</h1><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd xxx -<span class="keyword">g</span> groupName<span class="comment">//新增用户<span class="label">xxx并把它划分到groupName这个组</span></span></span><br><span class="line">passwd xxx <span class="comment">//为<span class="label">xxx用户设置密码</span></span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="linux" scheme="http://blog.angrytoro.com/categories/linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[chrome重度用户必备插件]]></title>
    <link href="http://blog.angrytoro.com/2015/03/09/chrome%E9%87%8D%E5%BA%A6%E7%94%A8%E6%88%B7%E5%BF%85%E8%A3%85%E6%8F%92%E4%BB%B6/"/>
    <id>http://blog.angrytoro.com/2015/03/09/chrome重度用户必装插件/</id>
    <published>2015-03-09T12:48:05.000Z</published>
    <updated>2015-03-09T13:49:48.000Z</updated>
    <content type="html"><![CDATA[<h1 id="此文原创，转载请标明出处。谢谢。">此文原创，转载请标明出处。谢谢。</h1><p>博主使用chrome将近5年，这些插件是博主在使用chrome时精心收藏下来的，大家定会喜欢。事先说明，这篇博文适合那些懂翻墙的人看。对于每个插件，相信大家会使用的，不会使用的在下面被博主留言，必仔细教你怎么使用。</p>
<h1 id="生活工具篇">生活工具篇</h1><ol>
<li><a href="https://chrome.google.com/webstore/detail/adblock/gighmmpiobklfepjocnamgkkbiglidom" target="_blank" rel="external">AdBlock</a>:这个屏蔽广告插件简直是妇孺皆知，这里就不都做介绍了。</li>
<li><a href="https://chrome.google.com/webstore/detail/cfhdojbkjhnklbpkdaibdccddilifddb" target="_blank" rel="external">Adblock Plus</a>:这个也是广告屏蔽插件，用了以上两个插件，妈妈再也不担心我被各种广告诱惑了。</li>
<li><a href="https://chrome.google.com/webstore/detail/ajgnnllmjadopdlmpplonojbfogkjlcl" target="_blank" rel="external">PasswordBox</a>:1Password有没有很贵，lastpass有没有很坑爹，说好的免费呢。好吧，博主是个穷逼，只能找个免费的用，PasswordBox这个插件是密码管理插件，已经被英特尔收购，使用简单方便，全平台支持（windows，mac，ios，mac，linux，Android）弱智都能上手，还免费，尤其还是有英特尔这个靠山，两三年内应该不会倒闭。</li>
<li><a href="https://chrome.google.com/webstore/detail/niloccemoadcdkdjlinkgdfekeahmflj" target="_blank" rel="external">Pocket</a>:大名鼎鼎的稍后阅读应用，看到那片文章好看，就直接用这个保存下来。改软件支持全平台。极力推荐。</li>
<li><a href="https://chrome.google.com/webstore/detail/ojcflmmmcfpacggndoaaflkmcoblhnbh" target="_blank" rel="external">Wunderlist</a>:说白了就是个todo工具，简单好用，也是支持全平台，不用担心，免费的。</li>
<li><a href="https://chrome.google.com/webstore/detail/keigpnkjljkelclbjbekcfnaomfodamj" target="_blank" rel="external">如意淘</a>:诶这大家一定要安装，网购比价神器，安装这个插件后，你只要浏览网站上的商品，它基本都会给你显示出最近一段时间，这个商品的价格走势。</li>
</ol>
<h1 id="开发篇">开发篇</h1><ol>
<li><a href="https://chrome.google.com/webstore/detail/ighdmehidhipcmcojjgiloacoafjmpfk" target="_blank" rel="external">AngularJS Batarang</a>:开发angular的时候必会用到的插件，功能强悍，用了就知道，这里不再详细介绍。</li>
<li><a href="https://chrome.google.com/webstore/detail/bhlhnicpbhignbdhedgjhgdocnmhomnp" target="_blank" rel="external">ColorZilla</a>:网页上的颜色取色器，对web开发人员或者设计上很用用处。</li>
<li><a href="https://chrome.google.com/webstore/detail/mfoaclfeiefiehgaojbmncmefhdnikeg" target="_blank" rel="external">HostAdmin App</a>:修改host应用，这个是离线应用，不是插件，原来是有插件的，相当好用，变成离线应用之后就just soso了。</li>
<li><a href="https://chrome.google.com/webstore/detail/kpfmckjjpabojdhlncnccfhkfhbmnjfi" target="_blank" rel="external">hosts文件管理工具</a>:也是个不错的hosts修改插件。</li>
<li><a href="https://chrome.google.com/webstore/detail/eglomijmggnafcfejliedcljabfgblia" target="_blank" rel="external">HTML 标签检测器|HTML TAG CHECKER</a>:这个插件是web开发神器，利用这个插件可以检查有哪些标签没有闭合。</li>
<li><a href="https://chrome.google.com/webstore/detail/iahnhfdhidomcpggpaimmmahffihkfnj" target="_blank" rel="external">JSON-handle</a>:这个就不用多介绍了，json格式化工具</li>
<li><a href="https://chrome.google.com/webstore/detail/jlpkojjdgbllmedoapgfodplfhcbnbpn" target="_blank" rel="external">Page Ruler</a>:尺子，web开发的时候，用来量网页上的尺寸。</li>
<li><a href="https://chrome.google.com/webstore/detail/dkaagdgjmgdmbnecmcefdhjekcoceebi" target="_blank" rel="external">PerfectPixel by WellDoneCode</a>:web开发的时候，用来对比写出来的html页面是不是跟设计稿一样，非常神器。</li>
<li><a href="https://chrome.google.com/webstore/detail/fhbjgbiflinjbdggehcddcbncdddomop" target="_blank" rel="external">Postman - REST Client</a>:提供功能强大的 Web API &amp; HTTP 请求调试。在调试接口的时候非常有用。</li>
<li><a href="https://github.com/justjavac/ReplaceGoogleCDN" target="_blank" rel="external">Replace Google CDN</a>: 把谷歌cdn重定向到国内的服务器。诶，大家懂的，这工具还是挺有用的。</li>
</ol>
<h1 id="图表篇">图表篇</h1><ol>
<li><a href="https://chrome.google.com/webstore/detail/bhmicilclplefnflapjmnngmkkkkpfad" target="_blank" rel="external">Gliffy Diagrams</a>:就是画图表的，例如流程图，用例图等，没啥好介绍的。</li>
<li><a href="https://chrome.google.com/webstore/detail/djejicklhojeokkfmdelnempiecmdomj" target="_blank" rel="external">Lucidchart 离线图表</a>:在线和离线绘制流程图、实体模型、UML、思维导图等。</li>
</ol>
<h1 id="其他">其他</h1><p>这些插件也是很好玩的</p>
<ol>
<li><a href="https://chrome.google.com/webstore/detail/dbepggeogbaibhgnhhndojpepiihcmeb" target="_blank" rel="external">Vimium</a>:这个插件可以让你用vim的快捷键来控制网页，超级好用。</li>
<li><a href="https://chrome.google.com/webstore/detail/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="external">Proxy SwitchyOmega</a>: 咋们想免费翻墙的时候经常需要用到的，轻松快捷地管理和切换多个代理设置。</li>
<li><a href="https://chrome.google.com/webstore/detail/kidnkfckhbdkfgbicccmdggmpgogehop" target="_blank" rel="external">马克飞象</a>: 个人觉得最好的MarkDown编辑器，没有之一。</li>
</ol>
<p>最后感谢这些开发者，给我们带来这么好的工具。</p>
]]></content>
    <summary type="html">
    <![CDATA[chrome从出世到现在，博主最喜爱的插件，都在此了。]]>
    
    </summary>
    
      <category term="chrome" scheme="http://blog.angrytoro.com/tags/chrome/"/>
    
      <category term="工具" scheme="http://blog.angrytoro.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[解决form.submit()无法触发onsubmit事件问]]></title>
    <link href="http://blog.angrytoro.com/2015/03/08/%E8%A7%A3%E5%86%B3form-submit-%E6%97%A0%E6%B3%95%E8%A7%A6%E5%8F%91onsubmit%E4%BA%8B%E4%BB%B6%E9%97%AE/"/>
    <id>http://blog.angrytoro.com/2015/03/08/解决form-submit-无法触发onsubmit事件问/</id>
    <published>2015-03-08T11:04:04.000Z</published>
    <updated>2015-03-08T11:04:40.000Z</updated>
    <content type="html"><![CDATA[<p>有时候我们需要直接执行form.submit()，然后又想监听onsubmit事件。但是在DHTML手册里写到:</p>
<blockquote>
<p>The submit method does not invoke the onsubmit event handler. Call the onsubmit event handler directly. When using Microsoft® Internet Explorer 5.5 and later, you can call the fireEvent method with a value of onsubmit in the sEvent parameter. </p>
</blockquote>
<p>大家知道啥回事了吧。原生js在执行<code>form.submit()</code>的时候根本不会去触发onsubmit事件。<br>所以在<code>submit</code>之前，先手动绑定一个<strong>submit</strong>事件（叫其他名字也行，如<strong>gaga</strong>）:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'xxx'</span>);</span><br><span class="line">$(form).bind(<span class="string">'submit'</span>,<span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123; <span class="comment">//绑定事件</span></span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(form.fireEvent) &#123; <span class="comment">// if IE Browser</span></span><br><span class="line">    form.fireEvent(<span class="string">'onsubmit'</span>); <span class="comment">//激活submit事件</span></span><br><span class="line">    form.submit(); <span class="comment">//促发sbumit事件</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">'HTMLEvents'</span>);</span><br><span class="line">    event.initEvent(<span class="string">'submit'</span>, <span class="literal">false</span>, <span class="literal">true</span>); <span class="comment">//初始化submit事件</span></span><br><span class="line">    event.dispatchEvent(event); <span class="comment">//触发submit事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是我们不能简单的<code>form.submit()</code>。得在之前构造相应的函数，太费劲了。尽量绕过这种需求吧，实在是没办法的时候再用这种解决方案。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有时候我们需要直接执行form.submit()，然后又想监听onsubmit事件。但是在DHTML手册里写到:</p>
<blockquote>
<p>The submit method does not invoke the onsubmit event handler]]>
    </summary>
    
      <category term="JavaScript" scheme="http://blog.angrytoro.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[不同浏览器求滚动距离的办法]]></title>
    <link href="http://blog.angrytoro.com/2015/03/08/%E4%B8%8D%E5%90%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B1%82%E6%BB%9A%E5%8A%A8%E8%B7%9D%E7%A6%BB%E7%9A%84%E5%8A%9E%E6%B3%95/"/>
    <id>http://blog.angrytoro.com/2015/03/08/不同浏览器求滚动距离的办法/</id>
    <published>2015-03-08T11:02:26.000Z</published>
    <updated>2015-03-08T11:03:15.000Z</updated>
    <content type="html"><![CDATA[<h1 id="chrome">chrome</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">document</span>.body.scrollTop</span><br><span class="line"><span class="number">2.</span> <span class="built_in">window</span>.pageYOffset</span><br><span class="line"><span class="number">3.</span> <span class="built_in">window</span>.scrollY</span><br></pre></td></tr></table></figure>
<h1 id="firefox">firefox</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">document</span>.documentElement.scrollTop</span><br><span class="line"><span class="number">2.</span> <span class="built_in">window</span>.pageYOffset</span><br><span class="line"><span class="number">3.</span> <span class="built_in">window</span>.scrollY</span><br></pre></td></tr></table></figure>
<h1 id="IE">IE</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">document</span>.body.scrollTop</span><br></pre></td></tr></table></figure>
<h1 id="注释">注释</h1><blockquote>
<p>还没有测试safari,估计跟chrome的差不多。同理可以求X轴的偏移量。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="chrome">chrome</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span clas]]>
    </summary>
    
      <category term="JavaScript" scheme="http://blog.angrytoro.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[IE9 BUG overflow :auto 底部空白解决方案]]></title>
    <link href="http://blog.angrytoro.com/2015/03/08/IE9-BUG-overflow-auto-%E5%BA%95%E9%83%A8%E7%A9%BA%E7%99%BD%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://blog.angrytoro.com/2015/03/08/IE9-BUG-overflow-auto-底部空白解决方案/</id>
    <published>2015-03-08T11:00:17.000Z</published>
    <updated>2015-03-08T11:01:09.000Z</updated>
    <content type="html"><![CDATA[<p>如果容器设置了max-height，overflow:auto。那么当js动态加载内容，或者鼠标点击容器的时候，容器底部会自动被撑大，留着空白。<br>解决办法是为容器添加min-height:0%。不过用grunt压缩的时候，会变成min-height:0;IE直接把这个当成min-height:0px。所以如果要压缩，那么我们应该把min-height设置成0.1%或者0.01%或者其他适合的数字。</p>
<h3 id="参考">参考</h3><p><a href="http://social.microsoft.com/Forums/id-ID/1c239c1d-84d2-461b-991d-d7834edaa121/ie9bug?forum=267" target="_blank" rel="external">ie9渲染bug</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如果容器设置了max-height，overflow:auto。那么当js动态加载内容，或者鼠标点击容器的时候，容器底部会自动被撑大，留着空白。<br>解决办法是为容器添加min-height:0%。不过用grunt压缩的时候，会变成min-height:0;IE直接把这个]]>
    </summary>
    
      <category term="hack" scheme="http://blog.angrytoro.com/tags/hack/"/>
    
      <category term="CSS" scheme="http://blog.angrytoro.com/categories/CSS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HTML中用到的data类型的url]]></title>
    <link href="http://blog.angrytoro.com/2015/03/08/HTML%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84data%E7%B1%BB%E5%9E%8B%E7%9A%84url/"/>
    <id>http://blog.angrytoro.com/2015/03/08/HTML中用到的data类型的url/</id>
    <published>2015-03-08T10:17:31.000Z</published>
    <updated>2015-03-08T10:17:46.000Z</updated>
    <content type="html"><![CDATA[<p>针对一些小的数据，我们可以直接在网页中嵌入，而不是引用外部文件，例如一些小的loading图片等。这样的好处是可以减少一次网络请求，缺点是页面内容变大。</p>
<hr>
<p>data的url类型有以下几种：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="typedef"><span class="keyword">data</span>:,&lt;文本数据&gt;</span></span><br><span class="line"><span class="typedef"><span class="keyword">data</span>:text/plain,&lt;文本数据&gt;</span></span><br><span class="line"><span class="typedef"><span class="keyword">data</span>:text/html,&lt;<span class="type">HTML</span>代码&gt;</span></span><br><span class="line"><span class="typedef"><span class="keyword">data</span>:text/html;base64,&lt;base64编码的<span class="type">HTML</span>代码&gt;</span></span><br><span class="line"><span class="typedef"><span class="keyword">data</span>:text/css,&lt;<span class="type">CSS</span>代码&gt;</span></span><br><span class="line"><span class="typedef"><span class="keyword">data</span>:text/css;base64,&lt;base64编码的<span class="type">CSS</span>代码&gt;</span></span><br><span class="line"><span class="typedef"><span class="keyword">data</span>:text/javascript,&lt;<span class="type">Javascript</span>代码&gt;</span></span><br><span class="line"><span class="typedef"><span class="keyword">data</span>:text/javascript;base64,&lt;base64编码的<span class="type">Javascript</span>代码&gt;</span></span><br><span class="line"><span class="typedef"><span class="keyword">data</span>:image/gif;base64,base64编码的gif图片数据</span></span><br><span class="line"><span class="typedef"><span class="keyword">data</span>:image/png;base64,base64编码的png图片数据</span></span><br><span class="line"><span class="typedef"><span class="keyword">data</span>:image/jpeg;base64,base64编码的jpeg图片数据</span></span><br><span class="line"><span class="typedef"><span class="keyword">data</span>:image/x-icon;base64,base64编码的icon图片数据</span></span><br></pre></td></tr></table></figure></p>
<p>一般我们经常用到的就是最下面跟图片有关的几种，当然黑客会经常用到<code>data:text/javascript,&lt;Javascript代码&gt;</code></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>针对一些小的数据，我们可以直接在网页中嵌入，而不是引用外部文件，例如一些小的loading图片等。这样的好处是可以减少一次网络请求，缺点是页面内容变大。</p>
<hr>
<p>data的url类型有以下几种：<br><figure class="highlight has]]>
    </summary>
    
      <category term="img" scheme="http://blog.angrytoro.com/tags/img/"/>
    
      <category term="HTML" scheme="http://blog.angrytoro.com/categories/HTML/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git常用命令]]></title>
    <link href="http://blog.angrytoro.com/2015/03/08/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://blog.angrytoro.com/2015/03/08/git常用命令/</id>
    <published>2015-03-08T10:15:55.000Z</published>
    <updated>2015-05-06T15:32:44.000Z</updated>
    <content type="html"><![CDATA[<ol>
<li><p><strong>Create a new repository on the command line</strong></p>
<blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch README.md&#10;git init&#10;git add README.md&#10;git commit -m &#34;first commit&#34;&#10;git remote add origin git@github.com:angrytoro/zepto.plug.git&#10;git push -u origin master</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>Push an existing repository from the command line</strong></p>
<blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:angrytoro/zepto.plug.git&#10;git push -u origin master</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>merge我们fork出来的源码</strong></p>
<blockquote>
<p>有一种情况，我们fork了项目A的源码，然后过段时间发现A有更新，这时咋整。这里举个博主fork的例子。<br>博主因为工作需要fork了去哪儿的开源项目<a href="https://github.com/rinh/fekit" target="_blank" rel="external">fekit</a>，名字叫<a href="https://github.com/angrytoro/fekit-plus" target="_blank" rel="external">fekit-plus</a>，过了几个月，发现fekit更新了好多，这是博主就需要merge了。OK，看下面步骤</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>git remote add rinh git<span class="variable">@github</span>.<span class="symbol">com:</span>rinh/fekit.git</span><br><span class="line"><span class="variable">$ </span>git fetch rinh</span><br><span class="line"><span class="variable">$ </span>git merge rinh/master</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<p>OK，搞定，就这么几步，不过merge的时候可能会出现冲突的情况.<br>本地的repository看上去是这样的：<br><img src="/img/git-fork-merge.png" alt="本地的repository"></p>
]]></content>
    <summary type="html">
    <![CDATA[<ol>
<li><p><strong>Create a new repository on the command line</strong></p>
<blockquote>
<figure class="highlight"><table><tr><td class="gu]]>
    </summary>
    
      <category term="git" scheme="http://blog.angrytoro.com/tags/git/"/>
    
      <category term="工具" scheme="http://blog.angrytoro.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Angularjs之Directive(指令)]]></title>
    <link href="http://blog.angrytoro.com/2015/03/08/Angularjs%E4%B9%8BDirective-%E6%8C%87%E4%BB%A4/"/>
    <id>http://blog.angrytoro.com/2015/03/08/Angularjs之Directive-指令/</id>
    <published>2015-03-08T10:13:49.000Z</published>
    <updated>2015-03-08T10:14:28.000Z</updated>
    <content type="html"><![CDATA[<p>简要的讲讲配置及要点，如果看不懂就看下面的参考lian</p>
<ol>
<li><strong><code>restrict:</code></strong>主要有两种<code>&quot;E&quot;(element)</code>和<code>&quot;A&quot;(attribute)</code>,分别是创建元素指令和属性指令用的。一般情况下只用到这两个。</li>
<li><strong><code>template:</code></strong>就是这个指令使用的模板。</li>
<li><strong><code>templateUrl:</code></strong>模板的url地址，主要是用这个。</li>
<li><strong><code>compile:</code></strong>当指令第一次被AngularJS编译的时候，<code>compile()</code>被调用，也就是说当AngularJS遇到第二个相同的指令的时候，不会再进行编译，<code>compile()</code>函数返回<code>link()</code>.该函数的写法是<code>function(element,attributes){//todo}</code>,<code>element</code>是该指令所在的元素对象，我们可以像在用jQuery操作dom一样操作它，<code>attributes</code>包含了dom元素所包含的所有属性集合的object对象。<a id="more"></a></li>
<li><strong><code>link:</code></strong>该函数每次跟<code>$scope</code>绑定的时，都会被调用，这个函数相当于，遇到数据时，就被调用，用来渲染dom（compile是创建dom），它带有3个参数，<code>$scope</code>,<code>element</code>,<code>attributes</code>,这两个参数就不多做解释了。(<strong>link和compile不能同时存在，否则只运行compile</strong>)</li>
<li><strong><code>transclude:</code></strong>用来指示directive是否包含directive所包含的内容,如果是的话，那么值为true,并且要在模板中相应的html元素上加上<code>ng-transclude</code>属性，来告诉angularjs，相应的内容要插到哪里。</li>
<li><strong><code>replace:</code></strong>这个比较经常用，用来告诉angularjs是否需要把我们编写的directive替换成规范的dom标签（自己尝试下就知道是干嘛用的了）。</li>
<li><strong><code>scope:</code></strong>这个属性比较复杂，还是看运行<a href="http://runjs.cn/code/rk9spiif" target="_blank" rel="external">实例</a>吧.</li>
<li><strong><code>controller:</code></strong><code>function($scope, $element, $attrs, $transclude){...}</code>,太烦了，不想写了，大家看参考吧。</li>
<li><strong><code>require:</code></strong>请求另外的<code>controller</code>,传入当前directive的linking function中.</li>
</ol>
<hr>
<h3 id="参考">参考</h3><blockquote>
<ol>
<li><a href="http://my.oschina.net/ilivebox/blog/289670" target="_blank" rel="external">AngularJS 自定义控件</a></li>
<li><a href="http://blog.51yip.com/jsjquery/1607.html" target="_blank" rel="external">angularjs directive 实例 详解</a></li>
<li><a href="http://www.ifeenan.com/angularjs/2014-08-19-%5B%E8%AF%91%5D%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3NG%E9%87%8C%E7%9A%84scope%2F" target="_blank" rel="external">深入理解ng里的scope</a></li>
<li><a href="http://www.html-js.com/article/Using-Angular-to-develop-web-application-to-AngularJS-instruction-to-create-controller-interacts-with-ngModel" target="_blank" rel="external">如何在AngularJS指令中创建controller与ngModel进行交互</a></li>
<li><a href="http://www.html-js.com/article/1985" target="_blank" rel="external">AngularJS指令进阶 — ngModelController详解</a>js.com/article/1985)</li>
</ol>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>简要的讲讲配置及要点，如果看不懂就看下面的参考lian</p>
<ol>
<li><strong><code>restrict:</code></strong>主要有两种<code>&quot;E&quot;(element)</code>和<code>&quot;A&quot;(attribute)</code>,分别是创建元素指令和属性指令用的。一般情况下只用到这两个。</li>
<li><strong><code>template:</code></strong>就是这个指令使用的模板。</li>
<li><strong><code>templateUrl:</code></strong>模板的url地址，主要是用这个。</li>
<li><strong><code>compile:</code></strong>当指令第一次被AngularJS编译的时候，<code>compile()</code>被调用，也就是说当AngularJS遇到第二个相同的指令的时候，不会再进行编译，<code>compile()</code>函数返回<code>link()</code>.该函数的写法是<code>function(element,attributes){//todo}</code>,<code>element</code>是该指令所在的元素对象，我们可以像在用jQuery操作dom一样操作它，<code>attributes</code>包含了dom元素所包含的所有属性集合的object对象。]]>
    
    </summary>
    
      <category term="AngularJS" scheme="http://blog.angrytoro.com/tags/AngularJS/"/>
    
      <category term="JavaScript" scheme="http://blog.angrytoro.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Angularjs实践（一）]]></title>
    <link href="http://blog.angrytoro.com/2015/03/08/Angularjs%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://blog.angrytoro.com/2015/03/08/Angularjs实践（一）/</id>
    <published>2015-03-08T10:12:24.000Z</published>
    <updated>2015-03-08T10:13:17.000Z</updated>
    <content type="html"><![CDATA[<h3 id="简单迭代器">简单迭代器</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">tr</span>&gt;</span><span class="tag">&lt;<span class="title">tr</span>&gt;</span><span class="tag">&lt;<span class="title">th</span>&gt;</span>row number<span class="tag">&lt;/<span class="title">th</span>&gt;</span><span class="tag">&lt;/<span class="title">tr</span>&gt;</span><span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">tr</span> <span class="attribute">ng-repeat</span>=<span class="value">"i in [0, 1, 2, 3, 4, 5, 6, 7]"</span>&gt;</span><span class="tag">&lt;<span class="title">td</span>&gt;</span>&#123; &#123;i+1&#125; &#125;<span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Angularjs会运行<code>{ { } }</code>中的表达式<br>for循环用in这个关键字来遍历</p>
<hr>
<h3 id="ngBind和ngBindTemplate">ngBind和ngBindTemplate</h3><p>这两个指令让页面在有相应model的时候才显示真正的内容，例如：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;title ng-<span class="keyword">bind</span>-<span class="keyword">template</span>=<span class="string">"Google Phone Gallery: &#123;&#123;query&#125;&#125;"</span>&gt;<span class="type">Google</span> <span class="type">Phone</span> <span class="type">Gallery</span>&lt;/title&gt;</span><br></pre></td></tr></table></figure></p>
<p>在没有query的时候，title显示的是Google Phone Gallery，当query有值得时候，会显示Google Phone Gallery:xxx。</p>
<hr>
<a id="more"></a>
<h3 id="过滤器和排序">过滤器和排序</h3><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">Search: <span class="tag">&lt;<span class="title">input</span> <span class="attribute">ng-model</span>=<span class="value">"query"</span>&gt;</span></span><br><span class="line">Sort by:</span><br><span class="line"><span class="tag">&lt;<span class="title">select</span> <span class="attribute">ng-model</span>=<span class="value">"orderProp"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">option</span> <span class="attribute">value</span>=<span class="value">"name"</span>&gt;</span>Alphabetical<span class="tag">&lt;/<span class="title">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">option</span> <span class="attribute">value</span>=<span class="value">"age"</span>&gt;</span>Newest<span class="tag">&lt;/<span class="title">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">ul</span> <span class="attribute">class</span>=<span class="value">"phones"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">li</span> <span class="attribute">ng-repeat</span>=<span class="value">"phone in phones | filter:query | orderBy:orderProp"</span>&gt;</span></span><br><span class="line">    </span><span class="expression">&#123;&#123;<span class="variable">phone.name</span>&#125;&#125;</span><span class="xml"></span><br><span class="line">    <span class="tag">&lt;<span class="title">p</span>&gt;</span></span><span class="expression">&#123;&#123;<span class="variable">phone.snippet</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p><code>filter</code>是Angularjs自带的过滤器，当用户输入的query值不同的时候，Angularjs会根据query，来过滤模型里面的数据，这里过滤的是phones中每个phone对象的数据（无论phone有多少对象，都要进行遍历）。<br><code>orderBy</code>是Angujs提供的排序工具，这里根据orderProp的值排序。</p>
<hr>
<h3 id="依赖注入和XHR">依赖注入和XHR</h3><p><strong>依赖注入:</strong>为了使用AngularJS的服务，你只需要在控制器的构造函数里面作为参数声明出所需服务的名字，就像这样：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> PhoneListCtrl($scope, $http) &#123;<span class="keyword">...</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的<code>$scope</code>和<code>$http</code>。当控制器构造的时候，AngularJS的依赖注入器会将这些服务注入到你的控制器中。当然，依赖注入器也会处理所需服务可能存在的任何传递性依赖（一个服务通常会依赖于其他的服务）。<br>注意到参数名字非常重要，因为注入器会用他们去寻找相应的依赖。</p>
<h4 id="‘$’前缀命名">‘$’前缀命名</h4><p>作为一个命名习惯，AngularJS内建服务，作用域方法，以及一些其他的AngularJS API都在名字前面使用一个‘<code>$</code>’前缀。不要使用‘<code>$</code>’前缀来命名你自己的服务和模型，否则可能会产生名字冲突。</p>
<h4 id="js压缩">js压缩</h4><p>由于AngularJS是通过控制器构造函数的参数名字来推断依赖服务名称的。所以大家就懂了。为了克服压缩造成的问题。Angularjs提供了两个解决方案：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhoneListCtrl.<span class="variable">$inject</span> = [<span class="string">'$scope'</span>, <span class="string">'$http'</span>];</span><br></pre></td></tr></table></figure></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> PhoneListCtrl = [<span class="string">'$scope'</span>, <span class="string">'$http'</span>, <span class="function"><span class="keyword">function</span><span class="params">(<span class="variable">$scope</span>, <span class="variable">$http</span>)</span> </span>&#123; <span class="comment">/* constructor body */</span> &#125;];</span><br></pre></td></tr></table></figure>
<p>按照自己的习惯来选择解决方案。</p>
<blockquote>
<p>上面的笔记都是查看<a href="http://angularjs.cn/" target="_blank" rel="external">Angularjs入门教程</a>前五节的总结。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="简单迭代器">简单迭代器</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">tr</span>&gt;</span><span class="tag">&lt;<span class="title">tr</span>&gt;</span><span class="tag">&lt;<span class="title">th</span>&gt;</span>row number<span class="tag">&lt;/<span class="title">th</span>&gt;</span><span class="tag">&lt;/<span class="title">tr</span>&gt;</span><span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">tr</span> <span class="attribute">ng-repeat</span>=<span class="value">"i in [0, 1, 2, 3, 4, 5, 6, 7]"</span>&gt;</span><span class="tag">&lt;<span class="title">td</span>&gt;</span>&#123; &#123;i+1&#125; &#125;<span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Angularjs会运行<code>{ { } }</code>中的表达式<br>for循环用in这个关键字来遍历</p>
<hr>
<h3 id="ngBind和ngBindTemplate">ngBind和ngBindTemplate</h3><p>这两个指令让页面在有相应model的时候才显示真正的内容，例如：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;title ng-<span class="keyword">bind</span>-<span class="keyword">template</span>=<span class="string">"Google Phone Gallery: &#123;&#123;query&#125;&#125;"</span>&gt;<span class="type">Google</span> <span class="type">Phone</span> <span class="type">Gallery</span>&lt;/title&gt;</span><br></pre></td></tr></table></figure></p>
<p>在没有query的时候，title显示的是Google Phone Gallery，当query有值得时候，会显示Google Phone Gallery:xxx。</p>
<hr>]]>
    
    </summary>
    
      <category term="AngularJS" scheme="http://blog.angrytoro.com/tags/AngularJS/"/>
    
      <category term="JavaScript" scheme="http://blog.angrytoro.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Angularjs实践（二）]]></title>
    <link href="http://blog.angrytoro.com/2015/03/08/Angularjs%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://blog.angrytoro.com/2015/03/08/Angularjs实践（二）/</id>
    <published>2015-03-08T10:08:54.000Z</published>
    <updated>2015-03-08T10:11:34.000Z</updated>
    <content type="html"><![CDATA[<h3 id="图片模板">图片模板</h3><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">ng-src</span>=<span class="value">"</span></span></span><span class="expression">&#123;&#123;<span class="variable">phone.imageUrl</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="value">"</span>&gt;</span><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>ng-src就是为了防止浏览器默认请求无效的图片地址，在页面还没初始化完成的时候，浏览器会在js代码执行前请求图片，所以直接设置src会导致浏览器请求无效地址，造成端口占用。</p>
<h2 id="路由与多视图">路由与多视图</h2><p>这个章节挺复杂的，需要花点时间理解，参考<a href="http://angularjs.cn/A00a" target="_blank" rel="external">AngularJS入门教程07：路由与多视图</a></p>
<hr>
<p>这个章节有几个注意点<br><a id="more"></a></p>
<ul>
<li><code>ng-view</code>指令的角色是为当前路由把对应的视图模板载入到布局模板中。</li>
<li><code>$routeProvider</code>:Angularjs中应用的路由通过它来生命，<code>$routeProvider</code>是<code>$route</code>服务的提供者。这项服务使得控制器、试图模板与当前浏览器的URL可以轻易集成。<code>$route</code>服务通常和<code>ng-view</code>指令一起使用。</li>
<li><strong>依赖注入：</strong>这东西自己根据前面章节，自己理解下</li>
<li><p><code>app.js</code>中模块定义和<code>controllers.js</code>的代码</p>
<blockquote>
<p>app.js中的代码：</p>
<pre><code><span class="comment"><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="reserved">var</span> phonecatApp = angular.<span class="built_in">module</span>(<span class="string">'phonecatApp'</span>, [</span><br><span class="line">  <span class="string">'ngRoute'</span>,</span><br><span class="line">  <span class="string">'phonecatControllers'</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure></span>
</code></pre></blockquote>
<pre><code>这里定义了phonecateApp模块，然后用到了ngRoute和phoneControllers这两个模块，phoneControllers是我们在`controllers.js`中定义的。
<span class="comment"><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">phonecatApp.config([<span class="string">'$routeProvider'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span><span class="params">(<span class="variable">$routeProvider</span>)</span> </span>&#123;</span><br><span class="line">    <span class="variable">$routeProvider</span>.</span><br><span class="line">      when(<span class="string">'/phones'</span>, &#123;</span><br><span class="line">        templateUrl: <span class="string">'partials/phone-list.html'</span>,</span><br><span class="line">        controller: <span class="string">'PhoneListCtrl'</span></span><br><span class="line">      &#125;).</span><br><span class="line">      when(<span class="string">'/phones/:phoneId'</span>, &#123;</span><br><span class="line">        templateUrl: <span class="string">'partials/phone-detail.html'</span>,</span><br><span class="line">        controller: <span class="string">'PhoneDetailCtrl'</span></span><br><span class="line">      &#125;).</span><br><span class="line">      otherwise(&#123;</span><br><span class="line">        redirectTo: <span class="string">'/phones'</span></span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;]);</span><br></pre></td></tr></table></figure></span>

这块代码里面的PhoneListCtrl和PhoneDetailCtrl在`controllers.js`中定义，并且挂在phoneControllers模块下面。这快代码的路由映射关系应该很容易理解，每个templateUrl对应一个controller。
</code></pre></li>
<li><p><strong>路由声明中参数的使用：</strong>注意到在第二条路由声明中:phoneId参数的使用。<code>$route</code>服务使用路由声明<code>/phones/:phoneId</code>作为一个匹配当前URL的模板。所有以<code>:</code>符号声明的变量（此处变量为phoneId）都会被提取，然后存放在<code>$routeParams</code>对象中。所以在PhoneDetailCtrl中我们就能按<code>$routeParams.phoneId</code>这种方式获取phoneId的值。</p>
</li>
<li>注意控制器与视图的对应关系。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="图片模板">图片模板</h3><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">img</span> <span class="attribute">ng-src</span>=<span class="value">"</span></span></span><span class="expression">&#123;&#123;<span class="variable">phone.imageUrl</span>&#125;&#125;</span><span class="xml"><span class="tag"><span class="value">"</span>&gt;</span><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>ng-src就是为了防止浏览器默认请求无效的图片地址，在页面还没初始化完成的时候，浏览器会在js代码执行前请求图片，所以直接设置src会导致浏览器请求无效地址，造成端口占用。</p>
<h2 id="路由与多视图">路由与多视图</h2><p>这个章节挺复杂的，需要花点时间理解，参考<a href="http://angularjs.cn/A00a">AngularJS入门教程07：路由与多视图</a></p>
<hr>
<p>这个章节有几个注意点<br>]]>
    
    </summary>
    
      <category term="AngularJS" scheme="http://blog.angrytoro.com/tags/AngularJS/"/>
    
      <category term="JavaScript" scheme="http://blog.angrytoro.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[AngularJS 从1.2迁移到1.3的变动记录]]></title>
    <link href="http://blog.angrytoro.com/2015/03/08/AngularJS-%E4%BB%8E1-2%E8%BF%81%E7%A7%BB%E5%88%B01-3%E7%9A%84%E5%8F%98%E5%8A%A8%E8%AE%B0%E5%BD%95/"/>
    <id>http://blog.angrytoro.com/2015/03/08/AngularJS-从1-2迁移到1-3的变动记录/</id>
    <published>2015-03-08T09:29:40.000Z</published>
    <updated>2015-03-08T09:51:40.000Z</updated>
    <content type="html"><![CDATA[<p>公司前端升级了<code>AngularJS</code>，那就顺便记录下1.2到1.3的变化吧。主要是记录一些可能大多数人会遇到的改变，以及1.3的新特性。</p>
<hr>
<h1 id="表达式解析">表达式解析</h1><ol>
<li>我们不能在表达式中使用以<code>.bind,.call,.apply</code>这些关键字命名的函数。例如<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span>&gt;&#123; &#123;user.sendInfo.call(&#123; &#125;, <span class="constant">true</span>)&#125; &#125;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这绝对会抛出异常</p>
<ol>
<li>在表达式中不能使用Object。例如<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scope.foo = &#123; <span class="string">"bar"</span>: <span class="built_in">Object</span> &#125;;</span><br><span class="line">scope.$<span class="built_in">eval</span>(<span class="string">'foo["bar"]'</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这绝对会抛出解析异常</p>
<ol>
<li>字符串<code>&#39;f&#39;, &#39;0&#39;, &#39;false&#39;, &#39;no&#39;, &#39;n&#39;, &#39;[]&#39;</code>不在被当做false来处理。只有<code>false,null, undefined,NaN,0,&quot;&quot;</code>被当做false来处理。</li>
</ol>
<blockquote>
<p>参考<a href="https://github.com/angular/angular.js/commit/528be29d1662122a34e204dd607e1c0bd9c16bbc" target="_blank" rel="external">528be29d</a></p>
</blockquote>
<a id="more"></a>
<h1 id="Angular工具函数">Angular工具函数</h1><ol>
<li><code>angylar.copy</code>：以前copy的时候原型链没有被真正的copy过去，只是用指针引用。现在全部都copy过去了。</li>
<li><code>angular.tojson</code>：双美元符号<code>$$</code>开头的字段直接被忽略。</li>
</ol>
<blockquote>
<p>参考<a href="https://github.com/angular/angular.js/commit/c054288c9722875e3595e6e6162193e0fb67a251" target="_blank" rel="external">c054288c</a></p>
</blockquote>
<h1 id="Angular_HTML编译器">Angular HTML编译器</h1><ol>
<li><code>replace</code>：指令里面的这个配置项将会在下个大发布中删除掉，所以大家从现在开始尽量不要用这个关键字。</li>
<li><code>attr.$observe</code>：不再返回一个observer函数（ps：用过的人都懂的）。</li>
</ol>
<blockquote>
<p>参考<a href="https://github.com/angular/angular.js/commit/299b220f5e05e1d4e26bfd58d0b2fd7329ca76b1" target="_blank" rel="external">299b220f</a></p>
</blockquote>
<h1 id="Forms,_Inputs_And_NgModel">Forms, Inputs And NgModel</h1><ol>
<li><p><code>ng-pattern</code>：给个升级前后的代码对比，大家就知道了</p>
 <figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//before</span></span><br><span class="line"><span class="variable">$scope</span>.<span class="keyword">exp</span> = <span class="string">'/abc/i'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//After</span></span><br><span class="line"><span class="variable">$scope</span>.<span class="keyword">exp</span> = /abc/i;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>$cancelUpdate()</code>：现在被改名成<code>$rollbackViewValue()</code></p>
</li>
<li><code>checkbox</code>: <code>ng-true-value,ng-false-value</code>里面只能放常量，比如数字或者字符<code>&#39;Y&#39;,&#39;N&#39;</code>记得字符常量一定要用引号包裹。</li>
<li><code>ngModelOptions</code>：新的牛逼指令，等下单独讲</li>
</ol>
<h1 id="Scopes_And_Digests">Scopes And Digests</h1><p><code>$broadcast</code>和<code>$emit</code>在事件结束后，会把<code>event.currentScope</code>设置为<code>null</code>，如果要获得相应的<code>scope</code>，那么我们使用<code>event.targetScope</code>来获取。</p>
<blockquote>
<p>参考<a href="https://github.com/angular/angular.js/commit/82f45aee5bd84d1cc53fb2e8f645d2263cdaacbc" target="_blank" rel="external">82f45aee</a></p>
</blockquote>
<h1 id="Server_Requests_($http,_$resource)">Server Requests ($http, $resource)</h1><p>主要的变化是删除了<code>$httpProvider</code>的属性<code>responseInterceptors</code>。现在这个拦截器已经不用了，所以我们还是老老实实使用<code>interceptors</code>吧。大家在迁移这个的时候，一定要注意逻辑，因为<code>responseInterceptors</code>返回的东西，在逻辑上很让人捉急，一不小心就会错误，然后让你排查到哭（偶就是干了这种事）。</p>
<blockquote>
<p>参考<a href="https://github.com/angular/angular.js/commit/ad4336f9359a073e272930f8f9bcd36587a8648f" target="_blank" rel="external">ad4336f9</a></p>
</blockquote>
<h1 id="新特性">新特性</h1><p>好了这是<code>AngularJS</code>给的一些大家最想要的功能。</p>
<h2 id="One-time_binding">One-time binding</h2><p>顾名思义就是只绑定一次，无论最后那个值在scope上怎么变化，那么在界面上永远只呈现第一次的赋值。用法<code>{ {::xxx} }</code>(xxx是scope上的一个值)。大家还是看例子<a href="https://docs.angularjs.org/guide/expression#one-time-binding" target="_blank" rel="external">one-time-binding</a><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//html 代码</span></span><br><span class="line">&lt;div ng-controller=<span class="string">"EventController"</span>&gt;</span><br><span class="line">  &lt;button ng-click=<span class="string">"clickMe($event)"</span>&gt;Click Me&lt;/button&gt;</span><br><span class="line">  &lt;p id=<span class="string">"one-time-binding-example"</span>&gt;One time binding: &#123; &#123;::name&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;p id=<span class="string">"normal-binding-example"</span>&gt;Normal binding: &#123; &#123;name&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//javascript 代码</span></span><br><span class="line">angular.module(<span class="string">'oneTimeBidingExampleApp'</span>, []).</span><br><span class="line">controller(<span class="string">'EventController'</span>, [<span class="string">'$scope'</span>, <span class="function"><span class="keyword">function</span><span class="params">(<span class="variable">$scope</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> names = [<span class="string">'Igor'</span>, <span class="string">'Misko'</span>, <span class="string">'Chirayu'</span>, <span class="string">'Lucas'</span>];</span><br><span class="line">  <span class="comment">/*</span><br><span class="line">   * expose the event object to the scope</span><br><span class="line">   */</span></span><br><span class="line">  <span class="variable">$scope</span>.clickMe = <span class="function"><span class="keyword">function</span><span class="params">(clickEvent)</span> </span>&#123;</span><br><span class="line">    <span class="variable">$scope</span>.name = names[counter % names.length];</span><br><span class="line">    counter++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure></p>
<h2 id="ngMessages">ngMessages</h2><p>这个指令用来展示form填写错误时的提示信息。使用方式也是比较简单，看个例子就很容易明白。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;form <span class="property">name</span>=<span class="string">"myForm"</span>&gt;</span><br><span class="line">  &lt;label&gt;Enter your <span class="property">name</span>:&lt;/label&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span></span><br><span class="line">         <span class="property">name</span>=<span class="string">"myName"</span></span><br><span class="line">         ng-model=<span class="string">"name"</span></span><br><span class="line">         ng-minlength=<span class="string">"5"</span></span><br><span class="line">         ng-maxlength=<span class="string">"20"</span></span><br><span class="line">         required /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;pre&gt;myForm.myName.$<span class="keyword">error</span> = &#123; &#123; myForm.myName.$<span class="keyword">error</span> | json &#125;&#125;&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">  &lt;<span class="keyword">div</span> ng-messages=<span class="string">"myForm.myName.$error"</span> style=<span class="string">"color:maroon"</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> ng-message=<span class="string">"required"</span>&gt;You did <span class="keyword">not</span> enter a field&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> ng-message=<span class="string">"minlength"</span>&gt;Your field <span class="keyword">is</span> too short&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">    &lt;<span class="keyword">div</span> ng-message=<span class="string">"maxlength"</span>&gt;Your field <span class="keyword">is</span> too long&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">  &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="ngModelOptions">ngModelOptions</h2><p>这东西如果详细讲起来，又是一篇博客。这里就简要的说一下吧，不明白的直接看<a href="https://docs.angularjs.org/api/ng/directive/ngModelOptions" target="_blank" rel="external">文档</a>，文档还是说得很详细的。<br>这个指令的主要功能，是可以让我们定义一系列事件来触发model更新或者延迟model更新，这个指令的一个经典用例是：当我们输入关键字来进行搜索的时候，我们不想让<code>AngularJS</code>马上响应输入框的值的变化，我们希望等到用户输入完成的时候再触发搜索。这个时候我们就可以用到<code>ngModelOptions</code>了。</p>
<h3 id="配置项说明">配置项说明</h3><p>就讲本人用到的，剩下的几个配置项，没有用过，就不好在这里说。希望有高人把它给补齐了。</p>
<ol>
<li><code>updateOn</code>：为input绑定model更新事件，有个<code>default</code>的默认事件。可以同时绑定多个事件，用空格隔开。这个属性可以跟<code>debounce</code>配合使用。<blockquote>
<p>备注：由于文档上没有说可以绑定哪些事件，在查看源码的时候发现了一段代码</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; element.on(modelCtrl.<span class="variable">$options</span>.updateOn, <span class="function"><span class="keyword">function</span><span class="params">(ev)</span> </span>&#123;</span><br><span class="line">&gt;   modelCtrl.<span class="variable">$$debounceViewValueCommit</span>(ev &amp;&amp; ev.type);</span><br><span class="line">&gt; &#125;);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<blockquote>
<p>因此可以90%肯定，可以绑定任何跟该元素有关的原生事件。</p>
</blockquote>
<ol>
<li><code>debounce</code>：没有包含这个属性的input,model会根据<code>updateOn</code>来更新值。如果包含这个属性，那么model就会根据<code>debounce</code>设置的参数来决定什么时候更新model。例如:<code>ng-model-options=&quot;{ updateOn: &#39;default blur&#39;, debounce: {&#39;default&#39;: 500, &#39;blur&#39;: 0} }&quot;</code>，default事件在input值变化后延迟500毫秒更新model，blur事件会马上触发model的更新。这个属性也可以单独使用，例如：<code>ng-model-options=&quot;{debounce: 1000}&quot;</code>。这表示在input值改变1秒之后改变model的值。</li>
</ol>
<blockquote>
<p>注意事项：</p>
<ol>
<li>我们可以用<code>$rollbackViewValue</code>来阻止model的变化。它的作用就是input显示的值回滚到上一次的记录。要使用这个东西，必须要为form表单和相应的input设置name属性。</li>
<li>还有一些特性请大家补充了。</li>
</ol>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>公司前端升级了<code>AngularJS</code>，那就顺便记录下1.2到1.3的变化吧。主要是记录一些可能大多数人会遇到的改变，以及1.3的新特性。</p>
<hr>
<h1 id="表达式解析">表达式解析</h1><ol>
<li>我们不能在表达式中使用以<code>.bind,.call,.apply</code>这些关键字命名的函数。例如<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span>&gt;&#123; &#123;user.sendInfo.call(&#123; &#125;, <span class="constant">true</span>)&#125; &#125;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这绝对会抛出异常</p>
<ol>
<li>在表达式中不能使用Object。例如<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scope.foo = &#123; <span class="string">"bar"</span>: <span class="built_in">Object</span> &#125;;</span><br><span class="line">scope.$<span class="built_in">eval</span>(<span class="string">'foo["bar"]'</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这绝对会抛出解析异常</p>
<ol>
<li>字符串<code>&#39;f&#39;, &#39;0&#39;, &#39;false&#39;, &#39;no&#39;, &#39;n&#39;, &#39;[]&#39;</code>不在被当做false来处理。只有<code>false,null, undefined,NaN,0,&quot;&quot;</code>被当做false来处理。</li>
</ol>
<blockquote>
<p>参考<a href="https://github.com/angular/angular.js/commit/528be29d1662122a34e204dd607e1c0bd9c16bbc">528be29d</a></p>
</blockquote>]]>
    
    </summary>
    
      <category term="AngularJS" scheme="http://blog.angrytoro.com/tags/AngularJS/"/>
    
      <category term="JavaScript" scheme="http://blog.angrytoro.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[angularjs开发笔记之ng-class]]></title>
    <link href="http://blog.angrytoro.com/2015/03/08/angularjs%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B9%8Bng-class/"/>
    <id>http://blog.angrytoro.com/2015/03/08/angularjs开发笔记之ng-class/</id>
    <published>2015-03-08T08:07:52.000Z</published>
    <updated>2015-03-08T10:06:13.000Z</updated>
    <content type="html"><![CDATA[<h4 id="参考AngularJS_ng-class用法">参考<a href="http://my.oschina.net/gejiawen0913/blog/188547" target="_blank" rel="external">AngularJS ng-class用法</a></h4><p><code>ng-class</code>有三种用法，最简单的就是<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> contrller($scope) &#123;</span><br><span class="line">    $scope.className = <span class="string">'abc'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;div class=<span class="string">"&#123;&#123;className&#125;&#125;"</span>&gt;</span><br><span class="line"><span class="keyword">...</span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>第二种：<br><a id="more"></a><br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> contrller($scope) &#123;</span><br><span class="line">    $scope.isActive = true;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;div ng-class=<span class="string">"&#123;true: 'active', false: 'inactive'&#125;[isActive]"</span>&gt;</span><br><span class="line"><span class="keyword">...</span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>这里的isActive也可以是简单的判断表达式，比如!!isActive.</p>
<hr>
<p>第三种：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> contrller($scope) &#123;</span><br><span class="line">    <span class="keyword">...</span></span><br><span class="line">&#125;;</span><br><span class="line">&lt;div ng-class=<span class="string">"&#123;'selected': isSelected, 'car': isCar&#125;"</span>&gt;&lt;/div&gt;</span><br><span class="line"><span class="keyword">...</span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>当 isSelected = true 则增加selected class，当isCar=true,则增加car class。以此类推。</p>
<hr>
<p>上面几种用法，大家应该看一眼就懂，在这就不再shuo</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="参考AngularJS_ng-class用法">参考<a href="http://my.oschina.net/gejiawen0913/blog/188547">AngularJS ng-class用法</a></h4><p><code>ng-class</code>有三种用法，最简单的就是<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> contrller($scope) &#123;</span><br><span class="line">    $scope.className = <span class="string">'abc'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;div class=<span class="string">"&#123;&#123;className&#125;&#125;"</span>&gt;</span><br><span class="line"><span class="keyword">...</span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>第二种：<br>]]>
    
    </summary>
    
      <category term="AngularJS" scheme="http://blog.angrytoro.com/tags/AngularJS/"/>
    
      <category term="JavaScript" scheme="http://blog.angrytoro.com/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[angularjs开发笔记之checkbox]]></title>
    <link href="http://blog.angrytoro.com/2015/03/08/angularjs%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B9%8Bcheckbox/"/>
    <id>http://blog.angrytoro.com/2015/03/08/angularjs开发笔记之checkbox/</id>
    <published>2015-03-08T08:06:45.000Z</published>
    <updated>2015-03-08T08:07:30.000Z</updated>
    <content type="html"><![CDATA[<p>这篇笔记终于不是参考国内的博文了。<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input <span class="keyword">type</span>=<span class="string">"checkbox"</span> ng-check=<span class="string">"&#123;&#123;xxx&#125;&#125;"</span> ng-<span class="literal">true</span>-<span class="keyword">value</span>=<span class="string">"yes"</span> ng-<span class="literal">false</span>-<span class="keyword">value</span>=<span class="string">"no"</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>ng-true-value</code>这个属性用来标识当该checkbox被选中时的值为多少。<br><code>ng-false-value</code>这个属性用来标识当该checkbox未被选中时的值为多少。<br><code>ng-check</code>这个属性与<code>ng-true-value</code>，<code>ng-false-value</code>配合来控制checkbox的选中状态</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇笔记终于不是参考国内的博文了。<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td cla]]>
    </summary>
    
      <category term="AngularJS" scheme="http://blog.angrytoro.com/tags/AngularJS/"/>
    
      <category term="JavaScript" scheme="http://blog.angrytoro.com/categories/JavaScript/"/>
    
  </entry>
  
</feed>